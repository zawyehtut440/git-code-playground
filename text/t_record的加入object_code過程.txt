t_record的格式: ["T", first_object_code_address, object_code, object_code, object_code]
t_record的初始化為: ["T"]
把t_record加到T_RECORD之前, 要先算出這個t_record的obj的object code的總長度
如果指令是RESB或RESW, 如果t_record有內容, 算出object code的總長度(單位: byte), 加到t_record的第2個位置
如下: ["T", first_object_code_address, (length of object_code), object_code, object_code, object_code]
然後加到T_RECORD中, 初始化新的t_record
如果指令是其他(WORD, BYTE, OPCODE)
    如果t_record為["T"]
        把目前的location counter加入t_record
    算出t_record的object code長度
    如果指令為OPCODE指令
        如果t_record的object code長度加上要新增的object code長度 > 60
            算出目前t_record的object code的總長度(單位: byte), 加到t_record的第2個位置
            把t_record加到T_RECORD
            初始化新的t_record為["T", locctr, 要新增的object_code]
        否則
            直接把要新增的object code加入t_record
    如果指令為WORD或BYTE
        當有object code 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
            如果t_record的object code長度加上要新增的object code長度 > 60
                算出要補多少個byte(兩個char算一個byte): 60-(t_record的object code長度)
                把要補的個數, 從要新增的object code中取得, 然後加到t_record中
                算出目前t_record的object code的總長度(單位: byte), 加到t_record的第2個位置
                把t_record加到T_RECORD
                更新object code為剩下的原本的object code
                
                如果剩下的object code的長度>60
                    初始化新的t_record為["T", locctr+(要補的個數, 要換算成byte), "1E", 要新增的object code]
                    60-len(object code)
                    更新object code為剩下的原本的object code
                    初始化新的t_record
                否則如果剩下的object code長度=60
                    初始化新的t_record為["T", locctr+(要補的個數, 要換算成byte), "1E", 要新增的object code]
                    初始化新的t_record
                否則剩下的object code的長度<60
                    初始化新的t_record為["T", locctr+(要補的個數, 要換算成byte), 要新增的object code]
                    object code = ''
            否則
                直接把要新增的object code加入t_record